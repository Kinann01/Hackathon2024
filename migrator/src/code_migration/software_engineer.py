import os

class SoftwareEngineer:
    def __init__(self, client, model, use_cache=False):
        self.client = client
        self.model = model

        self.use_cache = use_cache

        self.system_prompt = """
        Task Description:
        We migrate some project to a new technology. You are an experienced Software Engineer tasked with migrating an existing codebase to new technology. 
        You have to rewrite the codebase in new technology using guidelineses from Solution Architect, project structure, files contents.
        Your solution also has to pass all generated integration tests, so you preserve the API.
        """

        self.max_tokens = 4000
        self.migrated_files_dest_dir = "./migrated_code"

    def generate_migrated_code(self, instruction, tests, structure, contents):
        """
        docs : programmers documentation generated by the Solution Architect
        tests : tests generated by the Tester
        structure : project tree representation
        contents : dictionary of pairs (filename : content of the file)
        """
        
        task = f"""
        Create a detailed plan for rewriting an existing software system into a specified new technology stack. 
        This plan should leverage the provided programmer documentation, project structure, and specific migration instructions to ensure a smooth transition. 
        The output should include code for the new technology stack, organized by filename and content, ensuring a seamless integration and feature parity with the existing system.
        
        Provided Information:

        Migration Instructions: 
        {instruction}
        
        Integration tests (they have to pass!): 
        {tests}
        
        Project Structure: 
        {structure}

        File contents: 
        {contents}
        """ 

        expected_output_format = f"""
        Expected Output Format:
        For each key component identified in the programmer documentation and according to the project structure, generate the corresponding code in the new technology stack. The output should be formatted as follows for each new file created:

            Name of the New File: (e.g., GuestController.java)
            Content of the File: (The Java/Spring Boot equivalent of the original Python module, considering Spring Boot's conventions and the application's architectural requirements.)

        DO NOT INCLUDE ANYTHING BUT REQUIRED FORMAT OF (test_filename : [content of the test file]). DO NOT ADD ANY COMMENTS!
        Ensure that filenames include extensions corresponding to their programming language. For example, if you write tests for C#, generate files with .cs extension. 
        Important note: YOU HAVE TO IMPLEMENT ALL THE FUNCTIONALITY!
        Make sure you implement all the neccessary functionality
        """

        prompt = f"{task}\n\n{expected_output_format}"
        
        migrated_code = self.send_request(prompt)
        print(migrated_code)
        return self.parse_files(migrated_code)

    def modify_code(self, prev_version_of_code, modifications):
        task = f"""
        Modificate the Migrated Code below according to the these modifications: \"{modifications}\"
        
        Here is the previous version of code: 
        {prev_version_of_code}
        """

        expected_output_format = f"""
        Expected Output Format:
        For each key component identified in the programmer documentation and according to the project structure, generate the corresponding code in the new technology stack. The output should be formatted as follows for each new file created:

            Name of the New File: (e.g., GuestController.java)
            Content of the File: (The Java/Spring Boot equivalent of the original Python module, considering Spring Boot's conventions and the application's architectural requirements.)

        DO NOT INCLUDE ANYTHING BUT REQUIRED FORMAT OF (test_filename : [content of the test file]). DO NOT ADD ANY COMMENTS!
        Ensure that filenames include extensions corresponding to their programming language. For example, if you write tests for C#, generate files with .cs extension. 
        Important note: YOU HAVE TO IMPLEMENT ALL THE FUNCTIONALITY!
        Make sure you implement all the neccessary functionality
        """

        prompt = f"{task}\n\n{expected_output_format}"
        migrated_code = self.send_request(prompt)
        print(migrated_code)
        print(self.parse_files(migrated_code))
        return self.parse_files(migrated_code)

    def save_migrated_files(self, files_str):
        files = self.parse_files(files_str)
        # print(files)
        if not os.path.exists(self.migrated_files_dest_dir):
            os.makedirs(self.migrated_files_dest_dir)
        
        for filename, content in files.items():
            # Construct the full path where the file will be saved
            file_path = os.path.join(self.migrated_files_dest_dir, filename)
            
            # Write the content to the file
            with open(file_path, 'w', encoding='utf-8') as file:
                file.write(content)

    def parse_files(self, message):
        lines = message.split('\n')
        test_files = {}
        current_filename = None
        for line in lines:
            if line and (line.strip().startswith('Name of the New File') or line.strip().startswith('New File Name') or line.strip()[0] in ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']):
                try:
                    current_filename = line.strip().split(':')[1].strip().replace('\\', '')
                except:
                    current_filename = line.strip().split()[1]
                test_files[current_filename] = ""
            else:
                if current_filename:
                    if line.strip() == "```":
                        current_filename = None
                        continue

                    if line.strip().startswith("```") or line.strip().startswith("Content"):
                        continue
                    test_files[current_filename] += line + "\n"
        return test_files
    
    def send_request(self, prompt):
        print("Sending request...")
        chat_completion = self.client.chat.completions.create(
        messages=[
            {
            "role": "system",
            "content": self.system_prompt,
            },
            {
            "role": "user",
            "content": prompt,
            }
            ],
            model=self.model
        )

        return chat_completion.choices[0].message.content
    
if __name__ == "__main__":
    test_sw = SoftwareEngineer(None, None)
    with open("migrated_code.txt", "r") as file:
        files_str = file.read()
        res = test_sw.save_migrated_files(files_str)
        for item in res.items():
            print(f"Filename: {item[0]} : \nContent:{item[1]}")